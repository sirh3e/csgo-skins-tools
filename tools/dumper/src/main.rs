use clap::{App, Arg, ArgMatches};
use regex::Regex;
use std::collections::HashMap;
use std::fmt::Debug;
use std::fs::File;
use std::io::{Read, Write};
use std::path::PathBuf;

const ITEMS_GAME_PATH: &str = "./data/items_game.txt";

struct Args {
    item_game_file_path: String,
    dump_directory_path: String,
}

impl Args {
    fn from(matches: ArgMatches) -> Args {
        return Args {
            item_game_file_path: String::from(matches.value_of("src").unwrap_or(ITEMS_GAME_PATH)),
            dump_directory_path: String::from(matches.value_of("dst").unwrap()),
        };
        todo!("remove String::from make it nativ from &str")
    }
}

fn main() {
    let matches = App::new("dumper")
        .version("0.1.0")
        .author("sirh3e <sirh3e@prtonamil.com>")
        .about("Does awesome things")
        .arg(
            Arg::with_name("src")
                .short("s")
                .long("src")
                .value_name("FILE")
                .help("Location of items_game.txt file to generate map file")
                .takes_value(true),
        )
        .arg(
            Arg::with_name("dst")
                .short("d")
                .long("dst")
                .value_name("DIRECTORY")
                .help("Destination of dumps which will be generated by items_game.txt")
                .takes_value(true),
        )
        .get_matches();

    let args = Args::from(matches);

    let mut items_game =
        File::open(&args.item_game_file_path).unwrap_or(File::open(ITEMS_GAME_PATH).unwrap());

    let mut items_game_content = String::new();
    let size = items_game.read_to_string(&mut items_game_content).unwrap();
    println!("path: '{}' size: {}", &args.item_game_file_path, size);

    let regex = Regex::new("^\t\"[[:word:]]+\"").unwrap();

    let lines = items_game_content
        .split("\n")
        .map(|line| line.strip_prefix("\t").unwrap_or(line))
        .collect::<Vec<&str>>();

    let mut ranges = items_game_content
        .split("\n")
        .collect::<Vec<&str>>()
        .into_iter()
        .enumerate()
        .filter(|(index, line)| regex.is_match(line))
        .collect::<Vec<(usize, &str)>>();

    ranges.push((&lines.len() - 1, ""));

    let mut files: HashMap<&str, usize> = HashMap::new();
    let mut generated_dump_directory = PathBuf::from(&args.dump_directory_path);
    let mut name = "";
    let mut prev: usize = 0;
    for (index, line) in ranges.iter() {
        if name.len() == 0 {
            name = line;
            prev = *index;
            continue;
        }

        let count = files.entry(&name).or_insert(0);
        *count += 1;

        let file_name = format!("{:02}_{}.dump", count, &name[2..name.len() - 1]);
        let file_path = generated_dump_directory.join(file_name);

        let mut file = File::create(file_path).unwrap();
        let _a = file
            .write_all(&lines[prev..*index].join("\n").as_ref())
            .unwrap();

        name = line;
        prev = *index;
    }
}
